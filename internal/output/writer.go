package output

import (
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/morozRed/skelly/internal/fileutil"
	"github.com/morozRed/skelly/internal/graph"
	"github.com/morozRed/skelly/internal/parser"
)

const (
	SkellyDir    = ".skelly"
	ContextDir   = ".skelly/.context"
	IndexFile    = "index.txt"
	GraphFile    = "graph.txt"
	ModulesDir   = "modules"
	SymbolsFile  = "symbols.jsonl"
	EdgesFile    = "edges.jsonl"
	ManifestFile = "manifest.json"
)

type Format string

const (
	FormatText  Format = "text"
	FormatJSONL Format = "jsonl"
)

func ParseFormat(raw string) (Format, error) {
	format := Format(strings.ToLower(strings.TrimSpace(raw)))
	switch format {
	case "", FormatText:
		return FormatText, nil
	case FormatJSONL:
		return FormatJSONL, nil
	default:
		return "", fmt.Errorf("unsupported format %q (supported: text, jsonl)", raw)
	}
}

// Writer handles writing context output files under .skelly/.context/.
type Writer struct {
	rootPath   string
	contextDir string
}

// NewWriter creates a new output writer
func NewWriter(rootPath string) *Writer {
	return &Writer{
		rootPath:   rootPath,
		contextDir: filepath.Join(rootPath, ContextDir),
	}
}

// Init creates the output directory structure.
func (w *Writer) Init() error {
	dirs := []string{
		w.contextDir,
		filepath.Join(w.contextDir, ModulesDir),
	}

	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return fmt.Errorf("failed to create directory %s: %w", dir, err)
		}
	}

	return nil
}

// WriteAll writes all output files from the graph
func (w *Writer) WriteAll(g *graph.Graph, parseResult *parser.ParseResult, format Format) error {
	if err := w.Init(); err != nil {
		return err
	}

	switch format {
	case FormatText:
		if err := w.WriteIndex(g); err != nil {
			return err
		}
		if err := w.WriteGraph(g); err != nil {
			return err
		}
		if err := w.WriteModules(g, parseResult); err != nil {
			return err
		}
		if err := w.removeJSONLArtifacts(); err != nil {
			return err
		}
	case FormatJSONL:
		if err := w.WriteJSONL(g, parseResult); err != nil {
			return err
		}
		if err := w.removeTextArtifacts(); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported format %q", format)
	}

	return nil
}

// WriteIndex writes the index.txt file with top-level overview
func (w *Writer) WriteIndex(g *graph.Graph) error {
	var sb strings.Builder

	sb.WriteString("# Codebase Index\n")
	sb.WriteString("# Generated by skelly - https://github.com/morozRed/skelly\n\n")

	// Top symbols by importance
	sb.WriteString("## Key Symbols (by importance)\n\n")
	topNodes := g.TopNodes(20)
	for _, node := range topNodes {
		sb.WriteString(fmt.Sprintf("- %s [%s] %s\n",
			node.ID,
			node.Symbol.Kind.String(),
			node.Symbol.Signature,
		))
	}

	// File summary
	sb.WriteString("\n## Files\n\n")
	for _, file := range g.Files() {
		nodes := g.NodesForFile(file)
		sb.WriteString(fmt.Sprintf("- %s (%d symbols)\n", file, len(nodes)))
	}

	path := filepath.Join(w.contextDir, IndexFile)
	return fileutil.WriteIfChanged(path, []byte(sb.String()))
}

// WriteGraph writes the graph.txt adjacency list
func (w *Writer) WriteGraph(g *graph.Graph) error {
	var sb strings.Builder

	sb.WriteString("# Dependency Graph\n")
	sb.WriteString("# Format: source -> [dependencies]\n\n")

	for _, file := range g.Files() {
		nodes := g.NodesForFile(file)
		for _, node := range nodes {
			if len(node.OutEdges) > 0 {
				formattedEdges := formatEdgesWithConfidence(node)
				sb.WriteString(fmt.Sprintf("%s -> [%s]\n",
					node.ID,
					strings.Join(formattedEdges, ", "),
				))
			}
		}
	}

	path := filepath.Join(w.contextDir, GraphFile)
	return fileutil.WriteIfChanged(path, []byte(sb.String()))
}

// WriteModules writes per-module/directory context files
func (w *Writer) WriteModules(g *graph.Graph, parseResult *parser.ParseResult) error {
	// Group files by top-level directory
	modules := make(map[string][]string)

	for _, file := range g.Files() {
		module := getModuleName(file)
		modules[module] = append(modules[module], file)
	}

	// Create imports lookup
	fileImports := make(map[string][]string)
	for _, f := range parseResult.Files {
		fileImports[f.Path] = f.Imports
	}

	for _, files := range modules {
		sort.Strings(files)
	}

	moduleNames := make([]string, 0, len(modules))
	for module := range modules {
		moduleNames = append(moduleNames, module)
	}
	sort.Strings(moduleNames)

	desired := make(map[string]bool, len(moduleNames))
	for _, module := range moduleNames {
		files := modules[module]
		if err := w.writeModuleFile(module, files, g, fileImports); err != nil {
			return err
		}
		desired[moduleFilename(module)] = true
	}

	if err := w.removeStaleModuleFiles(desired); err != nil {
		return err
	}

	return nil
}

func (w *Writer) writeModuleFile(module string, files []string, g *graph.Graph, fileImports map[string][]string) error {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("# Module: %s\n\n", module))

	for _, file := range files {
		sb.WriteString(fmt.Sprintf("## %s\n", file))

		// Imports
		if imports, ok := fileImports[file]; ok && len(imports) > 0 {
			imports = append([]string(nil), imports...)
			sort.Strings(imports)
			sb.WriteString("imports: [")
			sb.WriteString(strings.Join(imports, ", "))
			sb.WriteString("]\n")
		}

		// Symbols
		nodes := g.NodesForFile(file)
		for _, node := range nodes {
			sb.WriteString(fmt.Sprintf("\n### %s [%s]\n",
				node.Symbol.Name,
				node.Symbol.Kind.String(),
			))
			sb.WriteString(fmt.Sprintf("sig: %s\n", node.Symbol.Signature))

			if node.Symbol.Doc != "" {
				sb.WriteString(fmt.Sprintf("doc: %s\n", node.Symbol.Doc))
			}

			if len(node.OutEdges) > 0 {
				sb.WriteString(fmt.Sprintf("calls: [%s]\n", strings.Join(formatEdgesWithConfidence(node), ", ")))
			}

			if len(node.InEdges) > 0 {
				inEdges := append([]string(nil), node.InEdges...)
				sort.Strings(inEdges)
				sb.WriteString(fmt.Sprintf("called_by: [%s]\n", strings.Join(inEdges, ", ")))
			}
		}

		sb.WriteString("\n")
	}

	// Sanitize module name for filename
	filename := moduleFilename(module)
	path := filepath.Join(w.contextDir, ModulesDir, filename)
	return fileutil.WriteIfChanged(path, []byte(sb.String()))
}

func getModuleName(file string) string {
	dir := filepath.Dir(file)
	if dir == "." {
		return "root"
	}
	// Take first directory component
	parts := strings.Split(dir, string(filepath.Separator))
	return parts[0]
}

func formatEdgesWithConfidence(node *graph.Node) []string {
	formatted := make([]string, 0, len(node.OutEdges))
	for _, edge := range node.OutEdges {
		confidence := node.OutEdgeConfidence[edge]
		if confidence == "" {
			confidence = "heuristic"
		}
		formatted = append(formatted, fmt.Sprintf("%s{%s}", edge, confidence))
	}
	sort.Strings(formatted)
	return formatted
}

func moduleFilename(module string) string {
	return strings.ReplaceAll(module, "/", "_") + ".txt"
}

type symbolRecord struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	Kind      string `json:"kind"`
	Signature string `json:"signature,omitempty"`
	File      string `json:"file"`
	Language  string `json:"language"`
	Line      int    `json:"line"`
	Doc       string `json:"doc,omitempty"`
}

type edgeRecord struct {
	SourceID   string `json:"source_id"`
	TargetID   string `json:"target_id"`
	Confidence string `json:"confidence"`
}

type manifestRecord struct {
	SchemaVersion string             `json:"schema_version"`
	Format        string             `json:"format"`
	Counts        manifestCount      `json:"counts"`
	Artifacts     []manifestArtifact `json:"artifacts"`
}

type manifestCount struct {
	Files   int `json:"files"`
	Symbols int `json:"symbols"`
	Edges   int `json:"edges"`
}

type manifestArtifact struct {
	Path string `json:"path"`
	Hash string `json:"hash"`
}

func (w *Writer) WriteJSONL(g *graph.Graph, parseResult *parser.ParseResult) error {
	fileLanguage := make(map[string]string, len(parseResult.Files))
	for _, file := range parseResult.Files {
		fileLanguage[file.Path] = file.Language
	}

	symbols := make([]symbolRecord, 0, len(g.Nodes))
	for _, file := range g.Files() {
		for _, node := range g.NodesForFile(file) {
			symbols = append(symbols, symbolRecord{
				ID:        node.ID,
				Name:      node.Symbol.Name,
				Kind:      node.Symbol.Kind.String(),
				Signature: node.Symbol.Signature,
				File:      node.File,
				Language:  fileLanguage[node.File],
				Line:      node.Symbol.Line,
				Doc:       node.Symbol.Doc,
			})
		}
	}

	edges := make([]edgeRecord, 0)
	for _, file := range g.Files() {
		for _, node := range g.NodesForFile(file) {
			for _, targetID := range node.OutEdges {
				confidence := node.OutEdgeConfidence[targetID]
				if confidence == "" {
					confidence = "heuristic"
				}
				edges = append(edges, edgeRecord{
					SourceID:   node.ID,
					TargetID:   targetID,
					Confidence: confidence,
				})
			}
		}
	}

	symbolsData, err := fileutil.EncodeJSONL(symbols)
	if err != nil {
		return err
	}
	symbolPath := filepath.Join(w.contextDir, SymbolsFile)
	if err := fileutil.WriteIfChanged(symbolPath, symbolsData); err != nil {
		return err
	}

	edgesData, err := fileutil.EncodeJSONL(edges)
	if err != nil {
		return err
	}
	edgesPath := filepath.Join(w.contextDir, EdgesFile)
	if err := fileutil.WriteIfChanged(edgesPath, edgesData); err != nil {
		return err
	}

	manifest := manifestRecord{
		SchemaVersion: "jsonl-v1",
		Format:        string(FormatJSONL),
		Counts: manifestCount{
			Files:   len(g.Files()),
			Symbols: len(symbols),
			Edges:   len(edges),
		},
		Artifacts: []manifestArtifact{
			{Path: SymbolsFile, Hash: shortHash(symbolsData)},
			{Path: EdgesFile, Hash: shortHash(edgesData)},
		},
	}
	manifestData, err := json.MarshalIndent(manifest, "", "  ")
	if err != nil {
		return err
	}
	manifestData = append(manifestData, '\n')

	manifestPath := filepath.Join(w.contextDir, ManifestFile)
	return fileutil.WriteIfChanged(manifestPath, manifestData)
}

func (w *Writer) removeStaleModuleFiles(desired map[string]bool) error {
	pattern := filepath.Join(w.contextDir, ModulesDir, "*.txt")
	existing, err := filepath.Glob(pattern)
	if err != nil {
		return err
	}

	for _, path := range existing {
		filename := filepath.Base(path)
		if desired[filename] {
			continue
		}
		if err := os.Remove(path); err != nil && !os.IsNotExist(err) {
			return err
		}
	}

	return nil
}

func (w *Writer) removeTextArtifacts() error {
	for _, filename := range []string{IndexFile, GraphFile} {
		path := filepath.Join(w.contextDir, filename)
		if err := os.Remove(path); err != nil && !os.IsNotExist(err) {
			return err
		}
	}
	return w.removeStaleModuleFiles(map[string]bool{})
}

func (w *Writer) removeJSONLArtifacts() error {
	for _, filename := range []string{SymbolsFile, EdgesFile, ManifestFile} {
		path := filepath.Join(w.contextDir, filename)
		if err := os.Remove(path); err != nil && !os.IsNotExist(err) {
			return err
		}
	}
	return nil
}

func shortHash(data []byte) string {
	sum := sha256.Sum256(data)
	return hex.EncodeToString(sum[:])[:16]
}
